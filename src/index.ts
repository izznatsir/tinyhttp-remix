import {
	createRequestHandler as createRemixRequestHandler,
	createReadableStreamFromReadable,
	writeReadableStreamToWritable,
	type AppLoadContext,
	type ServerBuild,
} from "@remix-run/node";
import {
	type Request as TinyhttpRequest,
	type Response as TinyhttpResponse,
	type Handler as TinyhttpHandler,
} from "@tinyhttp/app";

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by tinyhttp middleware like `req.session`.
 */
export interface GetLoadContextFunction {
	(
		req: TinyhttpRequest,
		res: TinyhttpResponse
	): AppLoadContext | Promise<AppLoadContext>;
}

/**
 * Returns a request handler for tinyhttp that serves the response using Remix.
 */
export function createRequestHandler({
	build,
	getLoadContext,
	mode = process.env.NODE_ENV,
}: {
	build: ServerBuild;
	getLoadContext?: GetLoadContextFunction;
	mode?: string;
}): TinyhttpHandler {
	let handleRequest = createRemixRequestHandler(build, mode);

	return async (req, res, _next) => {
		let request = createRemixRequest(req, res);
		let loadContext = await getLoadContext?.(req, res);
		let response = await handleRequest(request, loadContext);

		await sendRemixResponse(res, response);
	};
}

export function createRemixHeaders(
	requestHeaders: TinyhttpRequest["headers"]
): Headers {
	let headers = new Headers();

	for (let [key, values] of Object.entries(requestHeaders)) {
		if (values) {
			if (Array.isArray(values)) {
				for (let value of values) {
					headers.append(key, value);
				}
			} else {
				headers.set(key, values);
			}
		}
	}

	return headers;
}

export function createRemixRequest(
	req: TinyhttpRequest,
	res: TinyhttpResponse
): Request {
	let url = new URL(`${req.protocol}://${req.get("host")}${req.url}`);

	// Abort action/loaders once we can no longer write a response.
	let controller = new AbortController();
	res.on("close", () => controller.abort());

	let init: RequestInit = {
		method: req.method,
		headers: createRemixHeaders(req.headers),
		signal: controller.signal,
	};

	if (req.method !== "GET" && req.method !== "HEAD") {
		init.body = createReadableStreamFromReadable(req);
		init.duplex = "half";
	}

	return new Request(url.href, init);
}

export async function sendRemixResponse(
	res: TinyhttpResponse,
	remixResponse: Response
) {
	res.statusMessage = remixResponse.statusText;
	res.status(remixResponse.status);

	for (let [key, value] of remixResponse.headers.entries()) {
		res.append(key, value);
	}

	if (
		remixResponse.headers.get("Content-Type")?.match(/text\/event-stream/i)
	) {
		res.flushHeaders();
	}

	if (remixResponse.body) {
		await writeReadableStreamToWritable(remixResponse.body, res);
	} else {
		res.end();
	}
}
